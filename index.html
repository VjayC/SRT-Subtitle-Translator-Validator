<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRT Translator & Validator</title>

    <meta name="theme-color" content="#f5f5f7" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#000000" media="(prefers-color-scheme: dark)">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='grad' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23667eea;stop-opacity:1'/%3E%3Cstop offset='100%25' style='stop-color:%23764ba2;stop-opacity:1'/%3E%3C/linearGradient%3E%3CclipPath id='border-clip'%3E%3Cpath d='M50 2 C68 2 90 14 90 33 C90 66 68 98 50 98 C32 98 10 86 10 67 C10 34 32 2 50 2 Z'/%3E%3C/clipPath%3E%3C/defs%3E%3Cpath d='M50 2 C68 2 90 14 90 33 C90 66 68 98 50 98 C32 98 10 86 10 67 C10 34 32 2 50 2 Z' fill='url(%23grad)'/%3E%3Cpath d='M10 35 Q20 31 30 35 T50 35 T70 35 T90 35 M10 50 Q20 46 30 50 T50 50 T70 50 T90 50 M10 65 Q20 61 30 65 T50 65 T70 65 T90 65' stroke='white' stroke-width='6' stroke-linecap='round' opacity='0.5' fill='none' clip-path='url(%23border-clip)'/%3E%3C/svg%3E">
    <link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cdefs%3E%3ClinearGradient id='grad' x1='0%25' y1='0%25' x2='100%25' y2='100%25'%3E%3Cstop offset='0%25' style='stop-color:%23667eea;stop-opacity:1'/%3E%3Cstop offset='100%25' style='stop-color:%23764ba2;stop-opacity:1'/%3E%3C/linearGradient%3E%3CclipPath id='border-clip'%3E%3Cpath d='M50 2 C68 2 90 14 90 33 C90 66 68 98 50 98 C32 98 10 86 10 67 C10 34 32 2 50 2 Z'/%3E%3C/clipPath%3E%3C/defs%3E%3Cpath d='M50 2 C68 2 90 14 90 33 C90 66 68 98 50 98 C32 98 10 86 10 67 C10 34 32 2 50 2 Z' fill='url(%23grad)'/%3E%3Cpath d='M10 35 Q20 31 30 35 T50 35 T70 35 T90 35 M10 50 Q20 46 30 50 T50 50 T70 50 T90 50 M10 65 Q20 61 30 65 T50 65 T70 65 T90 65' stroke='white' stroke-width='6' stroke-linecap='round' opacity='0.5' fill='none' clip-path='url(%23border-clip)'/%3E%3C/svg%3E">
    <link rel="manifest" href="manifest.json">
    <style>
        :root {
            --bg-color: #000000;
            --container-bg: #0a0a0a;
            --container-border: #1a1a1a;
            --text-primary: #ffffff;
            --text-secondary: #ccc;
            --text-subtle: #666;
            --shadow-color: rgba(0, 0, 0, 0.8);
            --button-bg: #1a1a1a;
            --button-border: #333;
            --button-text: #888;
            --button-hover-bg: #222;
            --button-hover-border: #444;
            --button-hover-text: #aaa;
            --results-bg: #0f0f0f;
            --results-list-bg: #050505;
            --scrollbar-thumb: #333;
            --scrollbar-thumb-hover: #444;
            --success-color: #4ade80;
            --error-color: #f87171;
            --warning-color: #fbbf24;
        }

        @media (prefers-color-scheme: light) {
            :root {
                --bg-color: #f5f5f7;
                --container-bg: #ffffff;
                --container-border: #d2d2d7;
                --text-primary: #1d1d1f;
                --text-secondary: #333;
                --text-subtle: #6e6e73;
                --shadow-color: rgba(0, 0, 0, 0.1);
                --button-bg: #f5f5f7;
                --button-border: #d2d2d7;
                --button-text: #555;
                --button-hover-bg: #e8e8ed;
                --button-hover-border: #b2b2b7;
                --button-hover-text: #333;
                --results-bg: #f7f7f7;
                --results-list-bg: #ffffff;
                --scrollbar-thumb: #c1c1c1;
                --scrollbar-thumb-hover: #a8a8a8;
                --success-color: #22c55e;
                --error-color: #ef4444;
                --warning-color: #f59e0b;
            }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--bg-color);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: var(--container-bg);
            border: 1px solid var(--container-border);
            border-radius: 16px;
            padding: 40px;
            max-width: 1200px;
            margin: 0 auto;
            box-shadow: 0 20px 60px var(--shadow-color);
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
            font-weight: 600;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: var(--text-subtle);
            margin-bottom: 40px;
            font-size: 14px;
        }

        .config-section {
            margin-bottom: 30px;
            padding: 20px;
            background: var(--results-bg);
            border-radius: 12px;
            border: 1px solid var(--container-border);
        }

        .config-label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
        }

        .config-input {
            width: 100%;
            padding: 12px;
            background: var(--container-bg);
            border: 1px solid var(--container-border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
        }
        
        /* Style for template input labels */
        .template-var-label {
            display: block;
            margin-bottom: 8px;
            margin-top: 15px; /* Add spacing between inputs */
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
        }

        .prompt-textarea {
            width: 100%;
            min-height: 200px;
            padding: 12px;
            background: var(--container-bg);
            border: 1px solid var(--container-border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            overflow: hidden;
        }

        .prompt-preview {
            width: 100%;
            min-height: 200px;
            padding: 12px;
            background: var(--container-bg);
            border: 1px solid var(--container-border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 14px;
            overflow: visible;
            line-height: 1.6;
        }

        .prompt-preview h1, .prompt-preview h2, .prompt-preview h3 {
            margin-top: 1em;
            margin-bottom: 0.5em;
            color: var(--text-primary);
        }

        .prompt-preview h1 { font-size: 1.8em; border-bottom: 2px solid var(--container-border); padding-bottom: 0.3em; }
        .prompt-preview h2 { font-size: 1.5em; }
        .prompt-preview h3 { font-size: 1.3em; }

        .prompt-preview p { margin-bottom: 1em; }

        .prompt-preview ul, .prompt-preview ol { margin-left: 1.5em; margin-bottom: 1em; }

        .prompt-preview ul { 
            list-style-type: disc; 
            margin-left: 20px; 
        }

        /* This targets a list INSIDE a list (indented) */
        .prompt-preview ul ul { 
            list-style-type: circle; /* Hollow bullet */
            margin-left: 20px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        /* Optional: Level 3 nesting */
        .prompt-preview ul ul ul { 
            list-style-type: square; 
        }

        /* Ensure list items have some breathing room */
        .prompt-preview li {
            margin-bottom: 4px;
        }

        .prompt-preview code {
            background: var(--results-bg);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .prompt-preview pre {
            background: var(--results-bg);
            padding: 12px;
            border-radius: 8px;
            overflow-x: auto;
            margin-bottom: 1em;
        }

        .prompt-preview pre code {
            background: none;
            padding: 0;
        }

        .prompt-preview blockquote {
            border-left: 4px solid var(--container-border);
            padding-left: 1em;
            margin-left: 0;
            margin-bottom: 1em;
            color: var(--text-subtle);
        }

        .prompt-preview strong { font-weight: bold; }
        .prompt-preview em { font-style: italic; }

        .prompt-preview table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1em;
        }

        .prompt-preview table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1em;
        }

        .prompt-preview table th,
        .prompt-preview table td {
            border: 1px solid var(--container-border);
            padding: 8px 12px;
            text-align: left;
            vertical-align: top;
        }

        .prompt-preview table th {
            background: var(--results-bg);
            font-weight: bold;
            text-align: center;
        }

        .prompt-preview table td br,
        .prompt-preview table th br {
            display: block;
            content: "";
            margin: 0.5em 0;
        }

        .srt-editor {
            width: 100%;
            min-height: 300px;
            padding: 12px;
            background: var(--container-bg);
            border: 1px solid var(--container-border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 13px;
            font-family: 'Courier New', monospace;
            resize: vertical;
            overflow: hidden;
            margin-top: 20px;
        }

        .editor-section {
            margin-top: 30px;
            padding: 20px;
            background: var(--results-bg);
            border-radius: 12px;
            border: 1px solid var(--container-border);
            display: none;
        }

        .editor-section.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        .editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .editor-header-buttons {
            display: flex;
            gap: 10px;
        }

        .editor-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .script-search-container {
            position: relative;
            margin-bottom: 15px;
        }

        .script-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--container-bg);
            border: 1px solid var(--container-border);
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }

        .script-suggestions.show {
            display: block;
        }

        .script-suggestion-item {
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 14px;
            border-bottom: 1px solid var(--container-border);
        }

        .script-suggestion-item:last-child {
            border-bottom: none;
        }

        .script-suggestion-item:hover {
            background: var(--button-hover-bg);
        }

        .script-suggestion-name {
            font-weight: 500;
            color: var(--text-primary);
        }

        .script-suggestion-range {
            font-size: 12px;
            color: var(--text-subtle);
            margin-left: 8px;
        }

        .active-scripts {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .script-tag {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.15) 0%, rgba(118, 75, 162, 0.15) 100%);
            border: 1px solid #667eea;
            border-radius: 8px;
            font-size: 13px;
            color: var(--text-primary);
        }

        .script-tag.permanent {
            background: var(--button-bg);
            border: 1px solid var(--button-border);
            color: var(--text-subtle);
        }

        .remove-script {
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
            color: var(--error-color);
            line-height: 1;
            transition: transform 0.2s;
        }

        .remove-script:hover {
            transform: scale(1.2);
        }

        .custom-range-container {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .custom-range-container input {
            flex: 1;
            margin-bottom: 0 !important;
            min-width: 0;
        }

        .custom-range-container button {
            margin: 0;
            flex-shrink: 0;
        }

        .file-input-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .file-input-wrapper {
            position: relative;
        }

        .file-label {
            display: block;
            margin-bottom: 25px;
            color: var(--text-subtle);
            font-size: 14px;
            font-weight: 500;
        }

        .file-input {
            display: none;
        }

        .file-button {
            width: 100%;
            padding: 16px 20px;
            background: var(--button-bg);
            border: 2px dashed var(--button-border);
            border-radius: 12px;
            color: var(--button-text);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 15px;
            text-align: left;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-button:hover {
            background: var(--button-hover-bg);
            border-color: var(--button-hover-border);
            color: var(--button-hover-text);
        }

        .file-button.selected {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border: 2px solid #667eea;
            color: var(--text-primary);
        }

        .action-button {
            width: 100%;
            padding: 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .action-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .action-button.secondary {
            background: var(--button-bg);
            color: var(--text-primary);
            border: 2px solid var(--button-border);
        }

        .action-button.secondary:hover:not(:disabled) {
            background: var(--button-hover-bg);
            box-shadow: none;
        }

        .action-button.success {
            background: linear-gradient(135deg, var(--success-color) 0%, #22c55e 100%);
            color: #000000;
        }

        .results {
            margin-top: 40px;
            padding: 20px;
            background: var(--results-bg);
            border-radius: 12px;
            border: 1px solid var(--container-border);
            display: none;
            overflow: visible;
        }

        .results.show {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .success {
            color: var(--success-color);
            font-weight: 500;
        }

        .error {
            color: var(--error-color);
            font-weight: 500;
        }

        .warning {
            color: var(--warning-color);
            font-weight: 500;
        }

        .mismatch-list {
            margin-top: 20px;
            padding: 15px;
            background: var(--results-list-bg);
            border-radius: 8px;
            border: 1px solid var(--container-border);
        }

        .mismatch-item {
            margin-bottom: 12px;
            padding: 10px;
            background: var(--container-bg);
            border-radius: 6px;
            border-left: 3px solid var(--error-color);
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .mismatch-range {
            color: var(--error-color);
            font-weight: bold;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--container-border);
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }

        .stat-label {
            font-size: 12px;
            color: var(--text-subtle);
            margin-top: 5px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--container-border);
            border-radius: 50%;
            border-top-color: #667eea;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .results::-webkit-scrollbar {
            width: 8px;
        }

        .results::-webkit-scrollbar-track {
            background: var(--container-bg);
            border-radius: 4px;
        }

        .results::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb);
            border-radius: 4px;
        }

        .results::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        /* --- NEW DRAG-AND-DROP STYLES --- */

        /* Style for the SRT file drop zone when dragging over */
        .file-button.drag-over {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2) 0%, rgba(118, 75, 162, 0.2) 100%);
            border: 2px dashed #667eea;
            color: var(--text-primary);
            transform: scale(1.02); /* Subtle grow effect */
        }
        
        /* Style for the Template drop zone when dragging over */
        .config-section.drag-over-template {
            border: 2px dashed #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.2);
            background: var(--container-bg); /* Ensure background stays consistent */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SRT Translator & Validator</h1>
        <p class="subtitle">Translate, validate, and automatically fix subtitle files</p>

        <div class="config-section">
            <label class="config-label">CLI Proxy API Endpoint</label>
            <input type="text" id="api-endpoint" class="config-input" value="http://localhost:8317/v1/chat/completions" placeholder="http://localhost:8317/v1/chat/completions">
            
            <label class="config-label" style="margin-top: 15px;">Model Name</label>
            <input type="text" id="model-name" class="config-input" value="gemini-2.5-pro" placeholder="gemini-2.5-pro">
            
            <label class="config-label" style="margin-top: 15px;">API Key</label>
            <input type="text" id="api-key" class="config-input" value="" placeholder="Enter your API key from config.yaml...">
        </div>

        <div class="config-section">
            <label class="config-label">Allowed Script Ranges</label>
            <div class="script-search-container">
                <input type="text" id="script-search" class="config-input" placeholder="Search for a language script (e.g., Telugu, Arabic, Chinese)...">
                <div id="script-suggestions" class="script-suggestions"></div>
            </div>
            <div class="custom-range-container">
                <input type="text" id="custom-range-input" class="config-input" placeholder="Add custom: U+0C00-U+0C7F or U+0C00 or 0C00-0C7F">
                <button id="add-custom-range" class="action-button secondary" style="padding: 10px 16px; font-size: 14px; width: auto; flex-shrink: 0;">
                    ‚ûï Add
                </button>
            </div>
            <div id="active-scripts" class="active-scripts">
                <div class="script-tag" data-name="Basic Latin" data-start="0x0020" data-end="0x007E">
                    Basic Latin (U+0020-U+007E)
                    <span class="remove-script">√ó</span>
                </div>
                <div class="script-tag" data-name="Latin Supplement" data-start="0x00A0" data-end="0x00FF">
                    Latin Supplement (U+00A0-U+00FF)
                    <span class="remove-script">√ó</span>
                </div>
                <div class="script-tag permanent" data-name="Special Characters">
                    Special Characters (', ", ‚Äî, etc.)
                </div>
                <div class="script-tag permanent" data-name="Newlines">
                    Line Breaks
                </div>
            </div>
        </div>

        <input type="file" id="template-file-input" class="file-input" accept=".txt">

        <div class="config-section">
            <div class="editor-header">
                <label class="config-label" style="margin: 0;">Translation Prompt</label>
                <div class="editor-header-buttons">
                    <button id="import-template-btn" class="action-button secondary" style="width: auto; padding: 8px 16px; margin: 0; font-size: 14px;">
                        üì• Import Template
                    </button>
                    <button id="markdown-toggle-btn" class="action-button secondary" style="width: auto; padding: 8px 16px; margin: 0; font-size: 14px;">
                        üëÅÔ∏è Markdown View
                    </button>
                </div>
            </div>
            <textarea id="prompt-text" class="prompt-textarea" placeholder="Enter your translation instructions here, or import a template..."></textarea>
            <div id="prompt-preview" class="prompt-preview" style="display: none;"></div>
            
            <div id="template-inputs-container" class="config-section" style="display: none; margin-top: 20px; background: var(--container-bg);">
                </div>
        </div>

        <div class="file-input-container" style="grid-template-columns: 1fr;">
            <div class="file-input-wrapper">
                <label class="file-label">Input SRT File (Source)</label>
                <input type="file" id="srt-file" class="file-input" accept=".srt">
                <label for="srt-file" class="file-button" id="srt-file-button">
                    üìÑ Choose Input SRT file...
                </label>
            </div>
        </div>

        <button id="translate-btn" class="action-button" disabled>
            Translate with Gemini
        </button>

        <div id="editor-section" class="editor-section">
            <div class="editor-header">
                <span class="editor-title">üìù Translated SRT Content (Editable)</span>
                <button id="save-edit-btn" class="action-button secondary" style="width: auto; padding: 10px 20px; margin: 0;">
                    üíæ Save Edits
                </button>
            </div>
            <textarea id="srt-editor" class="srt-editor" placeholder="Translated content will appear here..."></textarea>
            <button id="continue-btn" class="action-button" style="display: none; margin-top: 15px;">
                ‚è© Continue Translating
            </button>
        </div>

        <div id="results" class="results"></div>

        <div id="action-buttons" style="display: none;">
            <div class="button-group">
                <button id="download-raw-btn" class="action-button secondary">
                    üìÑ Download Raw Output
                </button>
                <button id="fix-btn" class="action-button secondary">
                    üîß Fix All Errors
                </button>
            </div>
            <button id="download-btn" class="action-button success" style="margin-top: 10px;">
                üíæ Download Translated SRT
            </button>
        </div>
    </div>

    <script>
        let sourceFile = null;
        let promptText = null;
        let translatedSRT = null;
        let parsedSource = null;
        let parsedTranslated = null;
        let timestampMismatches = [];
        let rawOutputLog = ''; // Stores all raw outputs from Gemini
        let sourceFileName = ''; // Stores the original filename
        let isMarkdownView = false; // Tracks markdown view state
        let translationLanguage = ''; // Stores the detected language name
        let isPartialTranslation = false; // Tracks if translation is incomplete
        const originalTitle = document.title; // Store original title
        let rawTemplateText = ''; // Stores the raw template text
        let titleAnimationInterval = null; // Stores the timer ID for the title animation

        function setPageTitle(status) {
            // 1. Always clear any existing animation timer first
            if (titleAnimationInterval) {
                clearInterval(titleAnimationInterval);
                titleAnimationInterval = null;
            }

            if (status) {
                // 2. Check if the status implies a loading state (ends with "...")
                if (status.endsWith('...')) {
                    const baseText = status.slice(0, -3); // Remove the dots to get the base word (e.g., "Translating")
                    let frame = 0;

                    // Set initial title immediately
                    document.title = baseText;

                    // Start the animation loop
                    titleAnimationInterval = setInterval(() => {
                        frame = (frame + 1) % 4; // Cycles 0, 1, 2, 3
                        const dots = '.'.repeat(frame); // Creates "", ".", "..", or "..."
                        document.title = `${baseText}${dots}`;
                    }, 500); // 500ms speed (adjust as desired)
                    
                } else {
                    // 3. Static status (e.g., "Error!", "Fixed") - Show ONLY the status
                    document.title = status;
                }
            } else {
                // 4. Reset to the original website title
                document.title = originalTitle;
            }
        }

        // Unicode script ranges database (comprehensive list)
        const scriptRanges = {
            // Latin scripts
            'Basic Latin': { start: 0x0020, end: 0x007E },
            'Latin Supplement': { start: 0x00A0, end: 0x00FF },
            'Latin Extended-A': { start: 0x0100, end: 0x017F },
            'Latin Extended-B': { start: 0x0180, end: 0x024F },
            'Latin Extended Additional': { start: 0x1E00, end: 0x1EFF },
            'Latin Extended-C': { start: 0x2C60, end: 0x2C7F },
            'Latin Extended-D': { start: 0xA720, end: 0xA7FF },
            'Latin Extended-E': { start: 0xAB30, end: 0xAB6F },
            
            // Indian scripts
            'Devanagari (Hindi, Sanskrit, Marathi)': { start: 0x0900, end: 0x097F },
            'Bengali (Bangla)': { start: 0x0980, end: 0x09FF },
            'Gurmukhi (Punjabi)': { start: 0x0A00, end: 0x0A7F },
            'Gujarati': { start: 0x0A80, end: 0x0AFF },
            'Oriya (Odia)': { start: 0x0B00, end: 0x0B7F },
            'Tamil': { start: 0x0B80, end: 0x0BFF },
            'Telugu': { start: 0x0C00, end: 0x0C7F },
            'Kannada': { start: 0x0C80, end: 0x0CFF },
            'Malayalam': { start: 0x0D00, end: 0x0D7F },
            'Sinhala': { start: 0x0D80, end: 0x0DFF },
            
            // Southeast Asian scripts
            'Thai': { start: 0x0E00, end: 0x0E7F },
            'Lao': { start: 0x0E80, end: 0x0EFF },
            'Tibetan': { start: 0x0F00, end: 0x0FFF },
            'Burmese (Myanmar)': { start: 0x1000, end: 0x109F },
            'Khmer (Cambodian)': { start: 0x1780, end: 0x17FF },
            'Tagalog (Baybayin)': { start: 0x1700, end: 0x171F },
            'Balinese': { start: 0x1B00, end: 0x1B7F },
            'Sundanese': { start: 0x1B80, end: 0x1BBF },
            'Javanese': { start: 0xA980, end: 0xA9DF },
            
            // East Asian scripts
            'Chinese (CJK Unified Ideographs)': { start: 0x4E00, end: 0x9FFF },
            'Chinese (CJK Extension A)': { start: 0x3400, end: 0x4DBF },
            'Chinese (CJK Extension B)': { start: 0x20000, end: 0x2A6DF },
            'Chinese (CJK Extension C)': { start: 0x2A700, end: 0x2B73F },
            'Chinese (CJK Extension D)': { start: 0x2B740, end: 0x2B81F },
            'Chinese (CJK Extension E)': { start: 0x2B820, end: 0x2CEAF },
            'Chinese (CJK Compatibility)': { start: 0xF900, end: 0xFAFF },
            'Japanese Hiragana': { start: 0x3040, end: 0x309F },
            'Japanese Katakana': { start: 0x30A0, end: 0x30FF },
            'Japanese Katakana Phonetic': { start: 0x31F0, end: 0x31FF },
            'Korean Hangul Syllables': { start: 0xAC00, end: 0xD7AF },
            'Korean Hangul Jamo': { start: 0x1100, end: 0x11FF },
            'Korean Hangul Compatibility Jamo': { start: 0x3130, end: 0x318F },
            
            // Middle Eastern scripts
            'Arabic': { start: 0x0600, end: 0x06FF },
            'Arabic Supplement': { start: 0x0750, end: 0x077F },
            'Arabic Extended-A': { start: 0x08A0, end: 0x08FF },
            'Arabic Presentation Forms-A': { start: 0xFB50, end: 0xFDFF },
            'Arabic Presentation Forms-B': { start: 0xFE70, end: 0xFEFF },
            'Hebrew': { start: 0x0590, end: 0x05FF },
            'Syriac': { start: 0x0700, end: 0x074F },
            'Thaana (Maldivian)': { start: 0x0780, end: 0x07BF },
            'N\'Ko (West African)': { start: 0x07C0, end: 0x07FF },
            'Samaritan': { start: 0x0800, end: 0x083F },
            'Mandaic': { start: 0x0840, end: 0x085F },
            'Persian (Farsi)': { start: 0xFB50, end: 0xFDFF },
            'Urdu': { start: 0x0600, end: 0x06FF },
            
            // European scripts
            'Greek': { start: 0x0370, end: 0x03FF },
            'Greek Extended': { start: 0x1F00, end: 0x1FFF },
            'Cyrillic (Russian, Ukrainian, etc.)': { start: 0x0400, end: 0x04FF },
            'Cyrillic Supplement': { start: 0x0500, end: 0x052F },
            'Cyrillic Extended-A': { start: 0x2DE0, end: 0x2DFF },
            'Cyrillic Extended-B': { start: 0xA640, end: 0xA69F },
            'Cyrillic Extended-C': { start: 0x1C80, end: 0x1C8F },
            'Armenian': { start: 0x0530, end: 0x058F },
            'Georgian': { start: 0x10A0, end: 0x10FF },
            'Georgian Supplement': { start: 0x2D00, end: 0x2D2F },
            
            // African scripts
            'Ethiopic (Amharic, Tigrinya)': { start: 0x1200, end: 0x137F },
            'Ethiopic Supplement': { start: 0x1380, end: 0x139F },
            'Ethiopic Extended': { start: 0x2D80, end: 0x2DDF },
            'Tifinagh (Berber)': { start: 0x2D30, end: 0x2D7F },
            'Coptic': { start: 0x2C80, end: 0x2CFF },
            'Vai': { start: 0xA500, end: 0xA63F },
            'Bamum': { start: 0xA6A0, end: 0xA6FF },
            'Osmanya': { start: 0x10480, end: 0x104AF },
            
            // Native American scripts
            'Cherokee': { start: 0x13A0, end: 0x13FF },
            'Canadian Aboriginal Syllabics': { start: 0x1400, end: 0x167F },
            'Canadian Aboriginal Extended': { start: 0x18B0, end: 0x18FF },
            'Deseret': { start: 0x10400, end: 0x1044F },
            
            // Historical scripts
            'Phoenician': { start: 0x10900, end: 0x1091F },
            'Cuneiform': { start: 0x12000, end: 0x123FF },
            'Egyptian Hieroglyphs': { start: 0x13000, end: 0x1342F },
            'Anatolian Hieroglyphs': { start: 0x14400, end: 0x1467F },
            'Linear B Syllabary': { start: 0x10000, end: 0x1007F },
            'Linear B Ideograms': { start: 0x10080, end: 0x100FF },
            'Gothic': { start: 0x10330, end: 0x1034F },
            'Old Persian': { start: 0x103A0, end: 0x103DF },
            'Ugaritic': { start: 0x10380, end: 0x1039F },
            'Old Italic': { start: 0x10300, end: 0x1032F },
            'Runic': { start: 0x16A0, end: 0x16FF },
            'Ogham': { start: 0x1680, end: 0x169F },
            
            // Central/South Asian
            'Mongolian': { start: 0x1800, end: 0x18AF },
            'Phags-pa': { start: 0xA840, end: 0xA87F },
            'Limbu': { start: 0x1900, end: 0x194F },
            'Tai Le': { start: 0x1950, end: 0x197F },
            'New Tai Lue': { start: 0x1980, end: 0x19DF },
            'Tai Tham': { start: 0x1A20, end: 0x1AAF },
            'Tai Viet': { start: 0xAA80, end: 0xAADF },
            'Lepcha': { start: 0x1C00, end: 0x1C4F },
            'Ol Chiki': { start: 0x1C50, end: 0x1C7F },
            
            // Symbols and special
            'IPA Extensions': { start: 0x0250, end: 0x02AF },
            'Phonetic Extensions': { start: 0x1D00, end: 0x1D7F },
            'Phonetic Extensions Supplement': { start: 0x1D80, end: 0x1DBF },
            'General Punctuation': { start: 0x2000, end: 0x206F },
            'Currency Symbols': { start: 0x20A0, end: 0x20CF },
            'Mathematical Operators': { start: 0x2200, end: 0x22FF },
            'Box Drawing': { start: 0x2500, end: 0x257F },
            'Geometric Shapes': { start: 0x25A0, end: 0x25FF },
            'Miscellaneous Symbols': { start: 0x2600, end: 0x26FF },
            'Dingbats': { start: 0x2700, end: 0x27BF },
            'Emoticons': { start: 0x1F600, end: 0x1F64F },
            'Emoji (Supplemental Symbols)': { start: 0x1F300, end: 0x1F5FF },
        };

        // Active script ranges (starts with defaults)
        let activeScripts = [
            { name: 'Basic Latin', start: 0x0020, end: 0x007E, removable: true },
            { name: 'Latin Supplement', start: 0x00A0, end: 0x00FF, removable: true }
        ];

        // Helper function to validate and parse a script string (Name or Hex Range)
        function parseScriptInput(inputString) {
            const value = inputString.trim();
            
            // 1. Check if it's a named script in the database
            // We search case-insensitively against keys in scriptRanges
            const scriptName = Object.keys(scriptRanges).find(key => key.toLowerCase() === value.toLowerCase());
            if (scriptName) {
                return {
                    name: scriptName,
                    start: scriptRanges[scriptName].start,
                    end: scriptRanges[scriptName].end,
                    removable: true
                };
            }

            // 2. Check Custom Hex Ranges (Logic refactored from existing button)
            const upperValue = value.toUpperCase();
            let start, end, name;
            let match;

            // Format 1: U+0C00-U+0C7F
            match = upperValue.match(/U\+([0-9A-F]+)-U\+([0-9A-F]+)/);
            if (match) {
                start = parseInt(match[1], 16);
                end = parseInt(match[2], 16);
                name = `Custom Range U+${match[1]}-U+${match[2]}`;
            }

            // Format 2: 0C00-0C7F
            if (!match) {
                match = upperValue.match(/([0-9A-F]+)-([0-9A-F]+)/);
                if (match) {
                    start = parseInt(match[1], 16);
                    end = parseInt(match[2], 16);
                    name = `Custom Range U+${match[1]}-U+${match[2]}`;
                }
            }

            // Format 3: U+0C00 (single character)
            if (!match) {
                match = upperValue.match(/U\+([0-9A-F]+)/);
                if (match) {
                    start = parseInt(match[1], 16);
                    end = start;
                    name = `Custom Character U+${match[1]}`;
                }
            }

            // Format 4: 0C00 (single character, no U+)
            if (!match) {
                match = upperValue.match(/^([0-9A-F]+)$/);
                if (match) {
                    start = parseInt(match[1], 16);
                    end = start;
                    name = `Custom Character U+${match[1]}`;
                }
            }

            if (match && !isNaN(start) && !isNaN(end) && start <= end) {
                return { name, start, end, removable: true };
            }

            return null; // Invalid
        }

        function logRawOutput(content) {
            const now = new Date();
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            const month = monthNames[now.getMonth()];
            const day = now.getDate();
            const year = now.getFullYear();
            let hours = now.getHours();
            const minutes = now.getMinutes().toString().padStart(2, '0');
            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12 || 12;
            
            const timezoneName = now.toLocaleTimeString('en-US', { timeZoneName: 'short' }).split(' ').pop();
            const localTimestamp = `${month} ${day}, ${year}, ${hours}:${minutes} ${ampm} ${timezoneName}`;
            
            rawOutputLog += `\n${'='.repeat(80)}\n`;
            rawOutputLog += `Translation at: ${localTimestamp}\n`;
            rawOutputLog += `${'='.repeat(80)}\n`;
            rawOutputLog += content;
            rawOutputLog += `\n\n`;
        }

        function parseSRT(content) {
            const subtitles = [];
            if (!content) return subtitles;
            const blocks = content.trim().split(/\n\s*\n/);

            for (const block of blocks) {
                const lines = block.trim().split('\n');
                if (lines.length < 2) continue;

                const indexLine = lines[0];
                const timecodeLine = lines.length > 1 ? lines[1] : '';
                const textLines = lines.slice(2);

                const index = parseInt(indexLine);

                if (!isNaN(index) && timecodeLine.includes('-->')) {
                    subtitles.push({
                        index: index,
                        timecode: timecodeLine.trim(),
                        text: textLines.join('\n')
                    });
                }
            }
            return subtitles;
        }

        function updateEditorContent(shouldResize = true) {
            const editor = document.getElementById('srt-editor');
            const editorSection = document.getElementById('editor-section');
            if (translatedSRT) {
                editor.value = translatedSRT;
                editorSection.classList.add('show');
                // Only auto-resize if explicitly requested
                if (shouldResize) {
                    // Pass 'true' to force a shrink/reset to calculate exact height
                    autoResizeTextarea(editor, true); 
                }
            }
        }

        function autoResizeTextarea(textarea, shrink = false) {
            // We use clientHeight to get the current *visible* height,
            // which doesn't include the border. scrollHeight *does*.
            // This is a more accurate comparison.
            const currentHeight = textarea.clientHeight;
            const scrollHeight = textarea.scrollHeight;

            if (shrink) {
                // On 'blur', we're allowed to shrink.
                // Reset to auto and set the new correct height.
                textarea.style.height = 'auto';
                textarea.style.height = textarea.scrollHeight + 'px';
            } else if (scrollHeight > currentHeight) {
                // On 'input', only grow if the content (scrollHeight)
                // is larger than the current visible height.
                textarea.style.height = scrollHeight + 'px';
            }
            // If scrollHeight <= currentHeight and shrink is false, do nothing.
        }

        function parseMarkdown(markdown) {
            if (!markdown) return '';
            
            // 1. Initial cleanup
            let html = markdown
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');

            // 2. Block Elements (Code & Tables)
            html = html.replace(/```([\s\S]*?)```/g, '<pre><code>$1</code></pre>');

            const tableRegex = /\|(.+)\|\n\|[-:\s|]+\|\n((?:\|.+\|\n?)+)/gm;
            html = html.replace(tableRegex, function(match, headerRow, bodyRows) {
                const headers = headerRow.split('|').map(h => h.trim()).filter(h => h);
                const headerHtml = '<tr>' + headers.map(h => '<th>' + h + '</th>').join('') + '</tr>';
                const rows = bodyRows.trim().split('\n');
                const bodyHtml = rows.map(row => {
                    const cells = row.split('|').map(c => c.trim()).filter(c => c);
                    return '<tr>' + cells.map(c => '<td>' + c.replace(/&lt;br&gt;/g, '<br>') + '</td>').join('') + '</tr>';
                }).join('');
                return '<table>' + headerHtml + bodyHtml + '</table>';
            });

            // 3. ROBUST LIST PARSER (State Machine)
            let lines = html.split('\n');
            let result = [];
            let listStack = []; 
            
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                let match = line.match(/^(\s*)([-*]|\d+\.)\s+(.*)$/);

                if (match) {
                    let indent = match[1].length;
                    let isOrdered = /^\d+\./.test(match[2]);
                    let listType = isOrdered ? 'ol' : 'ul';
                    let content = match[3];

                    if (listStack.length === 0) {
                        result.push(`<${listType}>`);
                        listStack.push({ type: listType, indent: indent });
                    } else {
                        let lastItem = listStack[listStack.length - 1];

                        if (indent > lastItem.indent) {
                            result.push(`<${listType}>`);
                            listStack.push({ type: listType, indent: indent });
                        } else if (indent < lastItem.indent) {
                            while (listStack.length > 0 && indent < listStack[listStack.length - 1].indent) {
                                let closed = listStack.pop();
                                result.push(`</${closed.type}>`);
                            }
                            if (listStack.length > 0 && listStack[listStack.length - 1].type !== listType) {
                                let closed = listStack.pop();
                                result.push(`</${closed.type}><${listType}>`);
                                listStack.push({ type: listType, indent: indent });
                            }
                        } else {
                            if (lastItem.type !== listType) {
                                listStack.pop();
                                result.push(`</${lastItem.type}><${listType}>`);
                                listStack.push({ type: listType, indent: indent });
                            }
                        }
                    }
                    result.push(`<li>${content}</li>`);
                } else {
                    while (listStack.length > 0) {
                        let closed = listStack.pop();
                        result.push(`</${closed.type}>`);
                    }
                    result.push(line);
                }
            }
            while (listStack.length > 0) {
                let closed = listStack.pop();
                result.push(`</${closed.type}>`);
            }
            html = result.join('\n');

            // 4. Inline Formatting
            html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
            html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
            html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
            html = html.replace(/^&gt; (.*$)/gim, '<blockquote>$1</blockquote>');
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
            html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
            html = html.replace(/_(.+?)_/g, '<em>$1</em>');
            html = html.replace(/`(.+?)`/g, '<code>$1</code>');
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
            
            // Handle Hard Breaks (Two spaces at end of line)
            html = html.replace(/ {2,}\n/g, '<br>\n'); 

            // 5. Paragraphs (UPDATED: Grouping Logic)
            let finalLines = html.split('\n');
            let groupedHtml = [];
            let pBuffer = []; // Buffer for current paragraph lines

            const flushBuffer = () => {
                if (pBuffer.length > 0) {
                    // Join buffer lines with space/newline so they flow together
                    groupedHtml.push(`<p>${pBuffer.join('\n')}</p>`); 
                    pBuffer = [];
                }
            };

            const blockTags = ['<h', '<ul', '<ol', '<li', '<block', '<pre', '<table', '<tr', '<td', '<th', '<div', '</ul', '</ol', '</li', '</table', '</block', '</pre', '</div', '</h', '</tr', '</td', '</th'];
            const isBlock = (line) => blockTags.some(tag => line.trim().startsWith(tag));

            for (let i = 0; i < finalLines.length; i++) {
                let line = finalLines[i];

                if (isBlock(line) || line.trim() === '') {
                    // If we hit a block element or empty line, flush the current paragraph
                    flushBuffer();
                    if (line.trim() !== '') {
                        groupedHtml.push(line);
                    }
                } else {
                    // It's a text line, add to buffer
                    pBuffer.push(line);
                }
            }
            flushBuffer(); // Flush any remaining text at the end

            html = groupedHtml.join('\n');

            return html;
        }

        function checkLanguageScript(subtitles) {
            const errors = [];
            const isAllowedSpecial = (code) => [
                0x2018, 0x2019, 0x201C, 0x201D,
                0x200C, 0x2014
            ].includes(code);
            const isNewline = (code) => code === 0x000A;
            const isCarriageReturn = (code) => code === 0x000D;

            for (const sub of subtitles) {
                for (let i = 0; i < sub.text.length; i++) {
                    const char = sub.text[i];
                    const code = char.charCodeAt(0);
                    
                    // Check against active script ranges
                    let isAllowed = false;
                    
                    // Check fixed ranges
                    if (isAllowedSpecial(code) || isNewline(code) || isCarriageReturn(code)) {
                        isAllowed = true;
                    }
                    
                    // Check active custom ranges
                    if (!isAllowed) {
                        for (const script of activeScripts) {
                            if (code >= script.start && code <= script.end) {
                                isAllowed = true;
                                break;
                            }
                        }
                    }
                    
                    if (!isAllowed) {
                        errors.push({
                            index: sub.index,
                            line: sub.text.replace(/\n/g, ' '),
                            invalidChar: char,
                            unicode: `U+${code.toString(16).toUpperCase().padStart(4, '0')}`
                        });
                        break;
                    }
                }
            }
            return errors;
        }

        function handleSRTFile(file) {
            if (!file) return;

            // Check if the file name ends with .srt (case-insensitive)
            if (!file.name.toLowerCase().endsWith('.srt')) {
                alert('Invalid file type. Please upload a .srt file.');
                return;
            }

            sourceFileName = file.name.replace(/\.srt$/i, ''); // Remove .srt extension
            const reader = new FileReader();
            reader.onload = function(event) {
                sourceFile = event.target.result;
                parsedSource = parseSRT(sourceFile);
                document.getElementById('srt-file-button').classList.add('selected');
                document.getElementById('srt-file-button').textContent = `‚úì ${file.name}`;
                checkCanTranslate();
            };
            reader.readAsText(file);
        }

        // Updated 'change' listener to use the handler
        document.getElementById('srt-file').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                handleSRTFile(file);
            }
            // Reset file input
            e.target.value = null;
        });

        document.getElementById('prompt-text').addEventListener('input', function() {
            promptText = this.value;
            checkCanTranslate();
            // Auto-resize to fit content
            autoResizeTextarea(this, false);
        });

        document.getElementById('prompt-text').addEventListener('blur', function() {
            // When the user clicks away, call the resize function
            // and tell it that it's OK to shrink.
            autoResizeTextarea(this, true);
        });

        // --- NEW TEMPLATE FUNCTIONALITY ---

        document.getElementById('import-template-btn').addEventListener('click', function() {
            // Trigger the hidden file input
            document.getElementById('template-file-input').click();
        });

        function handleTemplateFile(file) {
            if (!file) return;
            
            // Check if the file name ends with .txt
            if (!file.name.toLowerCase().endsWith('.txt')) {
                alert('Invalid file type. Please upload a .txt file.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(event) {
                const fullContent = event.target.result; // Keep raw content with line breaks
                const lines = fullContent.split(/\r?\n/); // Split by newline

                // Check for @Config
                if (lines[0].trim() === '@Config') {
                    // --- VALIDATION START ---
                    
                    // Check structural integrity: @Config + 4 lines + 1 empty line
                    if (lines.length < 6 || lines[5].trim() !== '') {
                        alert('Invalid Template Config: The @Config header must be followed by exactly 4 lines of configuration and then an empty line.');
                        return;
                    }

                    // Helper regex to find {{...}}
                    const extractTags = (str) => [...str.matchAll(/\{\{(.+?)\}\}/g)].map(m => m[1]);

                    // Line 1: Endpoint (Exactly one pair)
                    const line1Tags = extractTags(lines[1]);
                    if (line1Tags.length !== 1 || !line1Tags[0].trim()) {
                        alert('Invalid Template Config (Line 2): Must contain exactly one non-empty {{Endpoint URL}}.');
                        return;
                    }

                    // Line 2: Model (Exactly one pair)
                    const line2Tags = extractTags(lines[2]);
                    if (line2Tags.length !== 1 || !line2Tags[0].trim()) {
                        alert('Invalid Template Config (Line 3): Must contain exactly one non-empty {{Model Name}}.');
                        return;
                    }

                    // Line 3: Scripts (At least one pair, valid scripts)
                    const line3Tags = extractTags(lines[3]);
                    if (line3Tags.length < 1) {
                        alert('Invalid Template Config (Line 4): Must contain at least one {{Script}} definition.');
                        return;
                    }

                    const parsedNewScripts = [];
                    for (const tag of line3Tags) {
                        const parsed = parseScriptInput(tag);
                        if (!parsed) {
                            alert(`Invalid Template Config (Line 4): "${tag}" is not a valid Script Name or Unicode Range.`);
                            return;
                        }
                        parsedNewScripts.push(parsed);
                    }

                    // Get body text (everything after line 6)
                    // We join back from line 6 onwards.
                    const bodyText = lines.slice(6).join('\n');
                    rawTemplateText = bodyText; // Store ONLY the body text for substitution later

                    // Check Placeholders in body
                    const placeholderRegex = /\{\{([\s\S]+?)\}\}/g;
                    const bodyPlaceholders = [...bodyText.matchAll(placeholderRegex)];
                    
                    // Get unique variable names (logic copied from parseAndDisplayTemplateInputs)
                    const uniqueNames = [];
                    const seen = new Set();
                    for (const match of bodyPlaceholders) {
                        const name = match[1].trim();
                        if (!seen.has(name)) {
                            seen.add(name);
                            uniqueNames.push(name);
                        }
                    }

                    // Line 4: Default Values (Must match unique placeholder count)
                    // Note: We allow empty values inside brackets {{}}, e.g., {{}}
                    const line4Tags = extractTags(lines[4]); 
                    // extractTags filters based on content, but regex `.+?` requires at least 1 char. 
                    // If the user puts {{}}, matchAll might fail with .+? depending on engine, 
                    // but standard regex usually wants something.
                    // We need a regex that allows empty: `\{\{(.*?)\}\}`
                    const extractTagsAllowEmpty = (str) => [...str.matchAll(/\{\{(.*?)\}\}/g)].map(m => m[1]);
                    const line4Values = extractTagsAllowEmpty(lines[4]);

                    if (line4Values.length !== uniqueNames.length) {
                        alert(`Invalid Template Config (Line 5): Found ${line4Values.length} default values, but the prompt has ${uniqueNames.length} unique placeholders.`);
                        return;
                    }

                    // --- VALIDATION PASSED: APPLY CONFIG ---

                    // 1. Set API Endpoint
                    const newEndpoint = line1Tags[0].trim();
                    document.getElementById('api-endpoint').value = newEndpoint;

                    // 2. Set Model Name
                    const newModel = line2Tags[0].trim();
                    document.getElementById('model-name').value = newModel;

                    // 3. Set Active Scripts
                    activeScripts = []; // Clear existing
                    parsedNewScripts.forEach(s => activeScripts.push(s));
                    updateActiveScriptsUI();

                    // 4. Populate Template Inputs (Pass defaults)
                    // We pass the raw values (untrimmed) as requested for defaults
                    parseAndDisplayTemplateInputs(rawTemplateText, line4Values);

                } else {
                    // No @Config detected, proceed as before
                    rawTemplateText = fullContent;
                    parseAndDisplayTemplateInputs(rawTemplateText, []);
                }
            };
            reader.readAsText(file);
            // Scroll to bottom of page
            setTimeout(() => {
                window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
            }, 100);
        }

        // Updated 'change' listener to use the handler
        document.getElementById('template-file-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                handleTemplateFile(file);
            }
            // Reset file input
            e.target.value = null;
        });

        // Updated function signature to accept defaultValues
        function parseAndDisplayTemplateInputs(templateContent, defaultValues = []) {
            const placeholderRegex = /\{\{([\s\S]+?)\}\}/g;
            const placeholders = [...templateContent.matchAll(placeholderRegex)];
            const container = document.getElementById('template-inputs-container');

            // Handle case where text exists but has no placeholders
            if (placeholders.length === 0) {
                alert('Invalid Template: No placeholders found.\nPlease use the {{Text}} format.');
                container.style.display = 'none';
                container.innerHTML = '';
                return;
            }

            // Get unique variable names
            const uniqueNames = [];
            const seen = new Set();
            for (const match of placeholders) {
                const name = match[1].trim();
                if (!seen.has(name)) {
                    seen.add(name);
                    uniqueNames.push(name);
                }
            }
            
            // Build the HTML for the inputs
            let inputsHtml = `<h3 style="color: var(--text-primary); margin-bottom: 15px;">Fill out the Template</h3>`;
            
            inputsHtml += uniqueNames.map((name, index) => {
                const prefillValue = (defaultValues && defaultValues[index]) ? defaultValues[index] : '';
                
                return `
                    <label class="template-var-label" for="template-var-${name.replace(/\s/g, '_')}">${name}:</label>
                    <input type="text" id="template-var-${name.replace(/\s/g, '_')}" 
                        class="config-input" 
                        data-varname="${name}" 
                        value="${prefillValue}"
                        placeholder="Enter here...">
                `;
            }).join('');

            // Add Apply AND Cancel buttons in a flex container
            inputsHtml += `
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button id="apply-template-btn" class="action-button" style="width: auto; padding: 10px 20px; font-size: 15px;">
                        Apply Template
                    </button>
                    <button id="cancel-template-btn" class="action-button secondary" style="width: auto; padding: 10px 20px; font-size: 15px; border-color: var(--error-color); color: var(--error-color);">
                        Cancel
                    </button>
                </div>
            `;
            
            container.innerHTML = inputsHtml;
            container.style.display = 'block';

            // --- Apply Button Logic ---
            document.getElementById('apply-template-btn').addEventListener('click', () => {
                let substitutedText = rawTemplateText;
                const inputs = container.querySelectorAll('.config-input[data-varname]');

                inputs.forEach(input => {
                    const varName = input.dataset.varname;
                    const value = input.value;
                    const regex = new RegExp(`\\{\\{\\s*${varName.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&')}\\s*\\}\\}`, 'g');
                    substitutedText = substitutedText.replace(regex, value);
                });

                const promptEditor = document.getElementById('prompt-text');
                promptEditor.value = substitutedText;
                promptText = substitutedText;

                autoResizeTextarea(promptEditor);
                checkCanTranslate();

                container.style.display = 'none';
                container.innerHTML = '';
                rawTemplateText = '';
                // Reset file input so the same file can be selected again
                document.getElementById('template-file-input').value = '';
            });

            // --- Cancel Button Logic ---
            document.getElementById('cancel-template-btn').addEventListener('click', () => {
                container.style.display = 'none';
                container.innerHTML = '';
                rawTemplateText = '';
                // Reset file input so the same file can be selected again
                document.getElementById('template-file-input').value = '';
            });
        }

        // --- END OF NEW TEMPLATE FUNCTIONALITY ---

        // --- NEW: DRAG AND DROP FUNCTIONALITY ---

        // Prevent browser from opening dropped files globally
        window.addEventListener('dragover', (e) => {
            e.preventDefault();
        }, false);
        window.addEventListener('drop', (e) => {
            e.preventDefault();
        }, false);

        // --- 1. SRT File Drop Zone ---
        const srtDropZone = document.getElementById('srt-file-button');

        ['dragenter', 'dragover'].forEach(eventName => {
            srtDropZone.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                srtDropZone.classList.add('drag-over');
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            srtDropZone.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                srtDropZone.classList.remove('drag-over');
            }, false);
        });

        srtDropZone.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                handleSRTFile(files[0]); // Use our reusable handler
            }
        }, false);


        // --- 2. Template File Drop Zone (on the prompt section) ---
        const templateDropZone = document.getElementById('prompt-text').closest('.config-section');

        ['dragenter', 'dragover'].forEach(eventName => {
            templateDropZone.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                // Check if the dragged item is a file to avoid styling on text drag
                if (e.dataTransfer.types.includes('Files')) {
                    templateDropZone.classList.add('drag-over-template');
                }
            }, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            templateDropZone.addEventListener(eventName, (e) => {
                e.preventDefault();
                e.stopPropagation();
                templateDropZone.classList.remove('drag-over-template');
            }, false);
        });

        templateDropZone.addEventListener('drop', (e) => {
            const dt = e.dataTransfer;
            const files = dt.files;
            
            if (files.length > 0) {
                handleTemplateFile(files[0]); // Use our reusable handler
            }
        }, false);

        // --- END OF DRAG AND DROP FUNCTIONALITY ---

        // Script search functionality
        const scriptSearch = document.getElementById('script-search');
        const scriptSuggestions = document.getElementById('script-suggestions');

        scriptSearch.addEventListener('input', function() {
            const query = this.value.toLowerCase().trim();
            
            if (query === '') {
                scriptSuggestions.classList.remove('show');
                return;
            }
            
            // Filter scripts based on search
            const filtered = Object.entries(scriptRanges).filter(([name]) => {
                return name.toLowerCase().includes(query);
            }).filter(([name]) => {
                // Don't show already active scripts
                return !activeScripts.some(s => s.name === name);
            });
            
            if (filtered.length === 0) {
                scriptSuggestions.innerHTML = '<div class="script-suggestion-item" style="color: var(--text-subtle);">No matching scripts found</div>';
                scriptSuggestions.classList.add('show');
                return;
            }
            
            // Display suggestions
            scriptSuggestions.innerHTML = filtered.map(([name, range]) => {
                const startHex = range.start.toString(16).toUpperCase().padStart(4, '0');
                const endHex = range.end.toString(16).toUpperCase().padStart(4, '0');
                return `<div class="script-suggestion-item" data-name="${name}" data-start="${range.start}" data-end="${range.end}">
                    <span class="script-suggestion-name">${name}</span>
                    <span class="script-suggestion-range">U+${startHex}-U+${endHex}</span>
                </div>`;
            }).join('');
            
            scriptSuggestions.classList.add('show');
        });

        // Click on suggestion to add script
        scriptSuggestions.addEventListener('click', function(e) {
            const item = e.target.closest('.script-suggestion-item');
            if (!item || !item.dataset.name) return;
            
            const name = item.dataset.name;
            const start = parseInt(item.dataset.start);
            const end = parseInt(item.dataset.end);
            
            // Add to active scripts
            activeScripts.push({ name, start, end, removable: true });
            
            // Update UI
            updateActiveScriptsUI();
            
            // Clear search
            scriptSearch.value = '';
            scriptSuggestions.classList.remove('show');
        });

        // Close suggestions when clicking outside
        document.addEventListener('click', function(e) {
            if (!scriptSearch.contains(e.target) && !scriptSuggestions.contains(e.target)) {
                scriptSuggestions.classList.remove('show');
            }
        });

        function updateActiveScriptsUI() {
            const container = document.getElementById('active-scripts');
            
            // Build HTML for active scripts
            let html = activeScripts.map(script => {
                const startHex = script.start.toString(16).toUpperCase().padStart(4, '0');
                const endHex = script.end.toString(16).toUpperCase().padStart(4, '0');
                return `<div class="script-tag" data-name="${script.name}" data-start="${script.start}" data-end="${script.end}">
                    ${script.name} (U+${startHex}-U+${endHex})
                    ${script.removable ? '<span class="remove-script">√ó</span>' : ''}
                </div>`;
            }).join('');
            
            // Add permanent tags
            html += `
                <div class="script-tag permanent" data-name="Special Characters">
                    Special Characters (', ", ‚Äî, etc.)
                </div>
                <div class="script-tag permanent" data-name="Newlines">
                    Line Breaks
                </div>
            `;
            
            container.innerHTML = html;
        }

        // Remove script functionality
        document.getElementById('active-scripts').addEventListener('click', function(e) {
            if (e.target.classList.contains('remove-script')) {
                const tag = e.target.closest('.script-tag');
                const name = tag.dataset.name;
                
                // Remove from activeScripts
                activeScripts = activeScripts.filter(s => s.name !== name);
                
                // Update UI
                updateActiveScriptsUI();
            }
        });

        // Add custom range functionality
        document.getElementById('add-custom-range').addEventListener('click', function() {
            const input = document.getElementById('custom-range-input');
            // parseScriptInput handles trimming and uppercase internally
            const parsedScript = parseScriptInput(input.value);
            
            if (!parsedScript) {
                alert('Invalid format. Please use:\n- U+0C00-U+0C7F\n- 0C00-0C7F\n- U+0C00\n- 0C00\n- Or check that the start value is less than or equal to end value');
                return;
            }
            
            // Check if already exists
            if (activeScripts.some(s => s.start === parsedScript.start && s.end === parsedScript.end)) {
                alert('This range is already added');
                return;
            }
            
            // Add to active scripts
            activeScripts.push(parsedScript);
            
            // Update UI
            updateActiveScriptsUI();
            
            // Clear input
            input.value = '';
        });

        // Allow Enter key to add custom range
        document.getElementById('custom-range-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                document.getElementById('add-custom-range').click();
            }
        });

        document.getElementById('markdown-toggle-btn').addEventListener('click', function() {
            const promptText = document.getElementById('prompt-text');
            const promptPreview = document.getElementById('prompt-preview');
            
            isMarkdownView = !isMarkdownView;
            
            if (isMarkdownView) {
                // Switch to markdown view
                promptPreview.innerHTML = parseMarkdown(promptText.value);
                promptText.style.display = 'none';
                promptPreview.style.display = 'block';
                this.textContent = '‚úèÔ∏è Edit Mode';
            } else {
                // Switch back to edit mode
                promptText.style.display = 'block';
                promptPreview.style.display = 'none';
                this.textContent = 'üëÅÔ∏è Markdown View';
                // Resize after switching back
                autoResizeTextarea(promptText);
            }
        });

        function checkCanTranslate() {
            const translateBtn = document.getElementById('translate-btn');
            if (sourceFile && promptText) {
                translateBtn.disabled = false;
            }
        }

        function checkAndHandlePartialTranslation() {
            const results = document.getElementById('results');
            const continueBtn = document.getElementById('continue-btn');
            
            if (parsedTranslated.length === 0) {
                results.innerHTML = '<div class="error">‚ùå No subtitles were translated. Please try again.</div>';
                setPageTitle('Error!');
                setTimeout(() => {
                    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                }, 100);
                return;
            }

            const lastTranslatedIndex = parsedTranslated[parsedTranslated.length - 1].index;
            const lastSourceIndex = parsedSource[parsedSource.length - 1].index;

            if (lastTranslatedIndex < lastSourceIndex) {
                // Partial translation detected
                isPartialTranslation = true;
                
                // Remove the last subtitle as it might be incomplete
                parsedTranslated.pop();
                
                // Update translatedSRT
                translatedSRT = parsedTranslated.map(sub => 
                    `${sub.index}\n${sub.timecode}\n${sub.text}`
                ).join('\n\n');
                
                updateEditorContent();
                
                const translatedCount = parsedTranslated.length;
                const totalCount = parsedSource.length;
                
                results.innerHTML = `
                    <div class="warning">‚ö†Ô∏è Partial Translation Detected!</div>
                    <div class="mismatch-list">
                        <p>Translated: ${translatedCount} / ${totalCount} subtitles</p>
                        <p>Last completed subtitle: #${parsedTranslated[parsedTranslated.length - 1].index}</p>
                        <p style="margin-top: 10px; color: var(--text-subtle);">The last subtitle was removed as it may be incomplete. Click "Continue Translating" to resume from where it stopped.</p>
                    </div>
                `;
                results.classList.add('show');
                
                // Show continue button
                continueBtn.style.display = 'block';
                
                // Scroll to bottom of page
                setTimeout(() => {
                    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                }, 100);
                
                setPageTitle('Partially Translated');
            } else {
                // Complete translation
                isPartialTranslation = false;
                continueBtn.style.display = 'none';
                updateEditorContent();
                validateTranslation();
                setPageTitle('Translated');
            }
        }

        async function continueTranslation() {
            const results = document.getElementById('results');
            const continueBtn = document.getElementById('continue-btn');
            const translateBtn = document.getElementById('translate-btn');
            
            results.innerHTML = '<div class="loading"></div> Continuing translation...';
            continueBtn.disabled = true;
            translateBtn.disabled = true; // Disable translate button during continuation

            setPageTitle('Translating...');

            try {
                const apiEndpoint = document.getElementById('api-endpoint').value.trim() || document.getElementById('api-endpoint').placeholder;
                const modelName = document.getElementById('model-name').value.trim() || document.getElementById('model-name').placeholder;
                const apiKey = document.getElementById('api-key').value || 'dummy';
                const nextIndex = parsedTranslated[parsedTranslated.length - 1].index + 1;

                const response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages: [
                            {
                                role: 'user',
                                content: `Begin from index ${nextIndex}\n` + promptText + '\n\n' + sourceFile
                            }
                        ],
                        stream: false
                    })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                let continuedSRT = data.choices[0].message.content;

                // Log raw output
                logRawOutput(continuedSRT);

                const codeBlockMatch = continuedSRT.match(/```(?:srt)?\n([\s\S]*?)\n```/);
                if (codeBlockMatch) {
                    continuedSRT = codeBlockMatch[1];
                }

                const continuedParsed = parseSRT(continuedSRT);
                
                // Append to existing translation
                parsedTranslated = parsedTranslated.concat(continuedParsed);
                
                // Update translatedSRT
                translatedSRT = parsedTranslated.map(sub => 
                    `${sub.index}\n${sub.timecode}\n${sub.text}`
                ).join('\n\n');

                // Check again for partial translation
                checkAndHandlePartialTranslation();
            } catch (error) {
                results.innerHTML = `<div class="error">‚ùå Continue Translation Error: ${error.message}</div>`;
                setPageTitle('Error!');
            } finally {
                continueBtn.disabled = false;
                translateBtn.disabled = false; // Re-enable translate button
            }
        }

        document.getElementById('translate-btn').addEventListener('click', async function() {
            const results = document.getElementById('results');
            const actionButtons = document.getElementById('action-buttons');
            const translateBtn = this;
            const continueBtn = document.getElementById('continue-btn');
            const editorSection = document.getElementById('editor-section');
            
            // Hide continue button if visible
            continueBtn.style.display = 'none';
            isPartialTranslation = false;
            
            actionButtons.style.display = 'none';
            editorSection.classList.remove('show');
            results.innerHTML = '<div class="loading"></div> Translating with Gemini...';
            results.classList.add('show');

            setTimeout(() => {
                window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
            }, 100);
            
            // Disable translate button
            translateBtn.disabled = true;

            setPageTitle('Translating...');

            try {
                const apiEndpoint = document.getElementById('api-endpoint').value.trim() || document.getElementById('api-endpoint').placeholder;
                const modelName = document.getElementById('model-name').value.trim() || document.getElementById('model-name').placeholder;
                const apiKey = document.getElementById('api-key').value || 'dummy';

                // First, detect the translation language
                results.innerHTML = '<div class="loading"></div> Detecting translation language...';
                
                const languageResponse = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'gemini-2.5-flash',
                        messages: [
                            {
                                role: 'user',
                                content: `Given this prompt [${promptText}], only output the name of the translation target language or the target code-mixed/code-switched vernacular (e.g., Tenglish, Hinglish).`
                            }
                        ],
                        stream: false
                    })
                });

                if (languageResponse.ok) {
                    const languageData = await languageResponse.json();
                    translationLanguage = languageData.choices[0].message.content.trim();
                    // Remove any quotes or extra formatting
                    translationLanguage = translationLanguage.replace(/['"]/g, '');
                } else {
                    translationLanguage = 'Translated'; // Fallback
                }

                // Now perform the actual translation
                results.innerHTML = '<div class="loading"></div> Translating with Gemini...';

                const response = await fetch(apiEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages: [
                            {
                                role: 'user',
                                content: promptText + '\n\n' + sourceFile
                            }
                        ],
                        stream: false
                    })
                });

                if (!response.ok) {
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                translatedSRT = data.choices[0].message.content;

                // Log raw output
                logRawOutput(translatedSRT);

                const codeBlockMatch = translatedSRT.match(/```(?:srt)?\n([\s\S]*?)\n```/);
                if (codeBlockMatch) {
                    translatedSRT = codeBlockMatch[1];
                }

                parsedTranslated = parseSRT(translatedSRT);
                
                // Check for partial translation
                checkAndHandlePartialTranslation();
            } catch (error) {
                results.innerHTML = `<div class="error">‚ùå Translation Error: ${error.message}</div>`;
                setPageTitle('Error!');
            } finally {
                // Re-enable translate button
                translateBtn.disabled = false;
            }
        });

        function validateTranslation() {
            const results = document.getElementById('results');
            const actionButtons = document.getElementById('action-buttons');

            if (parsedSource.length !== parsedTranslated.length) {
                results.innerHTML = `
                    <div class="error">‚ùå Critical Error: Subtitle count mismatch! Retranslation is recommended.</div>
                    <div class="mismatch-list">
                        <p>Source: ${parsedSource.length} subtitles</p>
                        <p>Translated: ${parsedTranslated.length} subtitles</p>
                    </div>
                `;
                setTimeout(() => {
                    window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
                }, 100);
                return;
            }

            // Add a flag to track if we have any previous content
            let hasPreviousContent = false;

            // Index sequence check
            let indexHtml = '';
            const indexSequenceErrors = [];
            for (let i = 1; i < parsedTranslated.length; i++) {
                if (parsedTranslated[i].index <= parsedTranslated[i-1].index) {
                    indexSequenceErrors.push({
                        position: i,
                        currentIndex: parsedTranslated[i].index,
                        previousIndex: parsedTranslated[i-1].index
                    });
                }
            }
            if (indexSequenceErrors.length > 0) {
                indexHtml = `<div class="error">‚ùå Index Sequence Errors Detected!</div><div class="mismatch-list">`;
                indexHtml += `<p style="margin-bottom: 15px; color: var(--warning-color);">‚ö†Ô∏è Subtitle indices must be strictly increasing. These errors may indicate duplicated or misordered subtitles. <strong>Manual review or retranslation is recommended.</strong></p>`;
                for (const err of indexSequenceErrors) {
                    indexHtml += `<div class="mismatch-item">After subtitle with index <span class="mismatch-range">${err.previousIndex}</span>, the next index is <span class="mismatch-range">${err.currentIndex}</span> (expected ${err.previousIndex + 1} or greater)</div>`;
                }
                indexHtml += `</div>`;
                hasPreviousContent = true;
            }

            timestampMismatches = [];
            let currentRange = null;

            for (let i = 0; i < parsedSource.length; i++) {
                if (!parsedSource[i] || !parsedTranslated[i] || parsedSource[i].timecode !== parsedTranslated[i].timecode) {
                    if (!parsedSource[i] || !parsedTranslated[i]) continue;
                    if (currentRange && currentRange.end === i - 1) {
                        currentRange.end = i;
                        currentRange.endIndex = parsedSource[i].index;
                    } else {
                        if (currentRange) timestampMismatches.push(currentRange);
                        currentRange = { start: i, end: i, startIndex: parsedSource[i].index, endIndex: parsedSource[i].index };
                    }
                } else {
                    if (currentRange) {
                        timestampMismatches.push(currentRange);
                        currentRange = null;
                    }
                }
            }
            if (currentRange) timestampMismatches.push(currentRange);

            let timestampHtml = '';
            if (timestampMismatches.length === 0) {
                timestampHtml = `
                    <div class="success">‚úÖ Perfect match! All timestamps are synchronized.</div>
                    <div class="stats">
                        <div class="stat-item"><div class="stat-value">${parsedSource.length}</div><div class="stat-label">Total Subtitles</div></div>
                        <div class="stat-item"><div class="stat-value">0</div><div class="stat-label">Mismatches</div></div>
                        <div class="stat-item"><div class="stat-value">100%</div><div class="stat-label">Sync Rate</div></div>
                    </div>
                `;
            } else {
                const mismatchCount = timestampMismatches.reduce((acc, range) => acc + (range.end - range.start + 1), 0);
                const syncRate = ((parsedSource.length - mismatchCount) / parsedSource.length * 100).toFixed(1);
                timestampHtml = `<div class="error">‚ùå Timestamp mismatches detected!</div><div class="warning" style="margin-top: 10px;">Found ${timestampMismatches.length} mismatch range(s):</div><div class="mismatch-list">`;
                for (const range of timestampMismatches) {
                    if (range.start === range.end) {
                        timestampHtml += `<div class="mismatch-item"><span class="mismatch-range">Subtitle #${range.startIndex}</span><br>Source: ${parsedSource[range.start].timecode}<br>Translated: ${parsedTranslated[range.start].timecode}</div>`;
                    } else {
                        timestampHtml += `<div class="mismatch-item"><span class="mismatch-range">Subtitles #${range.startIndex} to #${range.endIndex}</span><br>Range affects ${range.end - range.start + 1} subtitle(s)</div>`;
                    }
                }
                timestampHtml += `</div><div class="stats">
                    <div class="stat-item"><div class="stat-value">${parsedSource.length}</div><div class="stat-label">Total Subtitles</div></div>
                    <div class="stat-item"><div class="stat-value" style="color: var(--error-color);">${mismatchCount}</div><div class="stat-label">Mismatches</div></div>
                    <div class="stat-item"><div class="stat-value">${syncRate}%</div><div class="stat-label">Sync Rate</div></div>
                </div>`;
            }

            if (timestampHtml) {
                if (hasPreviousContent) {
                    timestampHtml = `<div style="margin-top: 30px; border-top: 1px solid var(--container-border); padding-top: 20px;">${timestampHtml}</div>`;
                }
                hasPreviousContent = true;
            }

            let languageHtml = '';
            const languageErrors = checkLanguageScript(parsedTranslated);
            if (languageErrors.length > 0) {
                languageHtml = `<div class="warning" style="margin-top: 30px; border-top: 1px solid var(--container-border); padding-top: 20px;">‚ö†Ô∏è Foreign Script Detected!</div><div class="mismatch-list">`;
                for (const err of languageErrors) {
                    languageHtml += `<div class="mismatch-item" style="border-left-color: var(--warning-color);"><strong>Subtitle #${err.index}:</strong> Found invalid character '<strong>${err.invalidChar}</strong>' (${err.unicode})<br><span style="color: var(--text-subtle);">Line: "${err.line}"</span></div>`;
                }
                languageHtml += `</div>`;
            }

            results.innerHTML = indexHtml + timestampHtml + languageHtml;
            actionButtons.style.display = 'block';
            
            // Scroll to bottom of page
            setTimeout(() => {
                window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
            }, 100);
        }

        document.getElementById('save-edit-btn').addEventListener('click', function() {
            const editor = document.getElementById('srt-editor');
            translatedSRT = editor.value;
            parsedTranslated = parseSRT(translatedSRT);
            
            // Auto-resize after saving
            autoResizeTextarea(editor);
            
            // Show feedback
            const originalText = this.textContent;
            this.textContent = '‚úì Saved!';
            setTimeout(() => {
                this.textContent = originalText;
            }, 2000);
        });

        document.getElementById('continue-btn').addEventListener('click', function() {
            continueTranslation();
        });

        document.getElementById('fix-btn').addEventListener('click', async function() {
            const fixBtn = this;
            const results = document.getElementById('results');
            const translateBtn = document.getElementById('translate-btn');
            
            // Check if there are any errors to fix
            const languageErrors = checkLanguageScript(parsedTranslated);
            const hasTimestampErrors = timestampMismatches.length > 0;
            const hasLanguageErrors = languageErrors.length > 0;
            
            if (!hasTimestampErrors && !hasLanguageErrors) {
                alert('No errors to fix!');
                return;
            }
            
            fixBtn.disabled = true;
            translateBtn.disabled = true;
            setPageTitle('Fixing...');
            
            // Fix timestamp errors first
            if (hasTimestampErrors) {
                for (const range of timestampMismatches) {
                    for (let i = range.start; i <= range.end; i++) {
                        parsedTranslated[i].timecode = parsedSource[i].timecode;
                    }
                }
            }
            
            // Fix language errors using Gemini
            if (hasLanguageErrors) {
                results.innerHTML = '<div class="loading"></div> Fixing foreign script errors with Gemini...';
                
                try {
                    // Get unique subtitle indices with errors
                    const errorIndices = [...new Set(languageErrors.map(err => err.index))];
                    
                    // Create subset of source subtitles
                    const subsetParsedSource = parsedSource
                        .filter(sub => errorIndices.includes(sub.index))
                        .map(sub => `${sub.index}\n${sub.timecode}\n${sub.text}`)
                        .join('\n\n');
                    
                    // Create subset of translated subtitles with error info
                    const subsetParsedTranslated = parsedTranslated
                        .filter(sub => errorIndices.includes(sub.index))
                        .map(sub => {
                            const error = languageErrors.find(err => err.index === sub.index);
                            if (error) {
                                return `${sub.index}: Found invalid character '${error.invalidChar}' (${error.unicode})\n${sub.timecode}\n${sub.text}`;
                            }
                            return `${sub.index}\n${sub.timecode}\n${sub.text}`;
                        })
                        .join('\n\n');
                    
                    // Call Gemini to fix the errors
                    const apiEndpoint = document.getElementById('api-endpoint').value.trim() || document.getElementById('api-endpoint').placeholder;
                    const modelName = document.getElementById('model-name').value.trim() || document.getElementById('model-name').placeholder;
                    const apiKey = document.getElementById('api-key').value || 'dummy';

                    const response = await fetch(apiEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${apiKey}`
                        },
                        body: JSON.stringify({
                            model: modelName,
                            messages: [
                                {
                                    role: 'user',
                                    content: `Given this prompt [${promptText}] and subset of the input SRT [${subsetParsedSource}] fix only these subtitles [${subsetParsedTranslated}]`
                                }
                            ],
                            stream: false
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API Error: ${response.status} ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    let fixedSRT = data.choices[0].message.content;
                    
                    // Log raw output
                    logRawOutput(fixedSRT);
                    
                    // Extract from code block if needed
                    const codeBlockMatch = fixedSRT.match(/```(?:srt)?\n([\s\S]*?)\n```/);
                    if (codeBlockMatch) {
                        fixedSRT = codeBlockMatch[1];
                    }
                    
                    // Parse the fixed subtitles
                    const fixedParsed = parseSRT(fixedSRT);
                    
                    // Replace the fixed subtitles in parsedTranslated
                    for (const fixedSub of fixedParsed) {
                        const index = parsedTranslated.findIndex(sub => sub.index === fixedSub.index);
                        if (index !== -1) {
                            parsedTranslated[index] = fixedSub;
                        }
                    }
                    
                } catch (error) {
                    results.innerHTML = `<div class="error">‚ùå Fix Error: ${error.message}</div>`;
                    fixBtn.disabled = false;
                    translateBtn.disabled = false;
                    setPageTitle('Error!');
                    return;
                }
            }
            
            // Update translatedSRT with all fixes
            translatedSRT = parsedTranslated.map(sub => 
                `${sub.index}\n${sub.timecode}\n${sub.text}`
            ).join('\n\n');

            updateEditorContent(false); // Don't resize to prevent scroll jump

            // Re-check for remaining language errors
            const remainingLanguageErrors = checkLanguageScript(parsedTranslated);
            let languageHtml = '';
            if (remainingLanguageErrors.length > 0) {
                languageHtml = `<div class="warning" style="margin-top: 30px; border-top: 1px solid var(--container-border); padding-top: 20px;">‚ö†Ô∏è Foreign Script Detected!</div><div class="mismatch-list">`;
                for (const err of remainingLanguageErrors) {
                    languageHtml += `<div class="mismatch-item" style="border-left-color: var(--warning-color);"><strong>Subtitle #${err.index}:</strong> Found invalid character '<strong>${err.invalidChar}</strong>' (${err.unicode})<br><span style="color: var(--text-subtle);">Line: "${err.line}"</span></div>`;
                }
                languageHtml += `</div>`;
            }

            results.innerHTML = `
                <div class="success">‚úÖ All errors have been fixed!</div>
                <div class="stats">
                    <div class="stat-item"><div class="stat-value">${parsedSource.length}</div><div class="stat-label">Total Subtitles</div></div>
                    <div class="stat-item"><div class="stat-value">0</div><div class="stat-label">Timestamp Errors</div></div>
                    <div class="stat-item"><div class="stat-value">${remainingLanguageErrors.length}</div><div class="stat-label">Script Errors</div></div>
                </div>
            ` + languageHtml;

            timestampMismatches = [];
            fixBtn.disabled = false;
            translateBtn.disabled = false;
            
            // Set title based on remaining errors
            if (remainingLanguageErrors.length === 0) {
                setPageTitle('Fixed!');
            } else {
                setPageTitle('Translated!');
            }
        });

        document.getElementById('download-btn').addEventListener('click', function() {
            if (!translatedSRT) {
                alert('No translated content to download!');
                return;
            }

            // Get model name and format it
            const modelName = document.getElementById('model-name').value.trim() || document.getElementById('model-name').placeholder;
            const formattedModelName = modelName
                .split('-')
                .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                .join(' ');

            // Create filename with language and model name
            let filename;
            if (sourceFileName && sourceFileName.trim() !== '') {
                filename = `${sourceFileName}(${translationLanguage})(${formattedModelName}).srt`;
            } else {
                filename = `translated_subtitles(${translationLanguage})(${formattedModelName}).srt`;
            }

            const blob = new Blob([translatedSRT], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        document.getElementById('download-raw-btn').addEventListener('click', function() {
            if (!rawOutputLog) {
                alert('No raw output to download!');
                return;
            }

            const blob = new Blob([rawOutputLog], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'gemini_raw_output.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
    </script>
</body>
</html>